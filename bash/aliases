#!/usr/bin/env bash

alias ls='ls --color'
alias grep="grep --color"
alias a='ls -A'
alias la='ls -A -l -G'
alias ll='ls -ltr'
alias cdd='cd -'
alias dl='dirs -v'
function cdc() {
	cd $1; ls
}
alias l="ls -ltrhG"
alias h="history"

alias dus='du -ms * | sort -n'

# find tmux pane from open file
function tmux_find_pane() {
	FNAME=$1
	(tmux switch -t $(tmux list-panes -a -F '#{session_name}:#{window_index}.#{pane_index} #{pane_tty}' | grep $(ps -o tty= -p $(lsof -t $FNAME))$ | awk '{ print $1 }'))
}

# Quick cd
function cr() {
	cd ~/projects/$*
}

which nvim 2>/dev/null >/dev/null
if [[ $? -eq 0 ]]; then
	alias vi=nvim
	export EDITOR=nvim
fi

# opening a file with docker container
function e() {
	set -e
	# TODO: iterate to resolve all files with realpath before invoking
	# for now just taking the first argument
	docker run -it --rm \
		-v $HOME:$HOME \
		-v /var/run/docker.sock:/var/run/docker.sock \
		-v /etc/localtime:/etc/localtime \
		-e TZ=America/Montreal \
		-e EUID=$UID \
		-e EGID=$GID \
		-e HOME=$HOME \
		vdesjardins/neovim $(realpath $1)
}

function e_debug() {
	docker run -it --rm \
		-v $HOME:$HOME \
		-v /var/run/docker.sock:/var/run/docker.sock \
		-v /etc/localtime:/etc/localtime \
		-e TZ=America/Montreal \
		-e EUID=$UID \
		-e EGID=$GID \
		-e HOME=$HOME \
		--entrypoint=/bin/bash \
		vdesjardins/neovim
}

function sf() {
	if [ "$#" -lt 1 ]; then echo "Supply string to search for!"; return 1; fi
	# printf -v search "%q" "$*"
	search="$1"
	include="yml,js,json,php,md,styl,pug,jade,html,config,py,cpp,c,go,hs,rb,conf,fa,lst,java"
	exclude=".config,.git,node_modules,vendor,build,yarn.lock,*.sty,*.bst,*.coffee,dist,*.class,*.war,*.jar"
	rg_command='rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --color "always" -g "*.{'$include'}" -g "!{'$exclude'}/*"'
	files=`eval $rg_command $search | fzf --ansi --multi --reverse | awk -F ':' '{print $1":"$2":"$3}'`
	[[ -n "$files" ]] && ${EDITOR:-vim} $files
}

# Utility
alias reload="source ~/dotfiles/bash/aliases"
alias ea="$EDITOR ~/dotfiles/bash/aliases; reload"
alias ee="$EDITOR ~/dotfiles/bash/env; source ~/dotfiles/bash/env"
alias eal="$EDITOR ~/.local.aliases; source ~/.local.aliases"
alias eel="$EDITOR ~/.local.env"
alias ef='$EDITOR $(fzf)'

# weather
alias weather="curl http://wttr.in/quebec_city"

# docker
alias d="sudo docker"
alias dri="sudo docker run -it --rm"

# ansible
alias ansible-pr="docker run -it -v $HOME/.ssh:/root/.ssh -v $SSH_AUTH_SOCK:/tmp/ssh.sck -e SSH_AUTH_SOCK=/tmp/ssh.sck -v $(pwd):/ansible -v ~/gce:~/gce --rm=true ansible ansible-playbook -b -u $USER -i inventory.yml site.yml"

function ansible-init() {
	mkdir -p group_vars
	mkdir -p host_vars
	touch site.yml
}

function ansible-role-init() {
	dir=$1
	mkdir -p roles/${dir}/tasks
	mkdir -p roles/${dir}/handlers
	mkdir -p roles/${dir}/templates
	mkdir -p roles/${dir}/files
	mkdir -p roles/${dir}/vars
	mkdir -p roles/${dir}/defaults
	mkdir -p roles/${dir}/meta
	touch roles/${dir}/tasks/main.yml
}

function ansible-role-clean() {
	find . -type d -empty

	echo "Do you wish to remove these directories?"
	select yn in "Yes" "No"; do
		case $yn in
			Yes ) find . -type d -empty -exec rm -rf '{}' \; 2>/dev/null; break;;
			No ) exit;;
		esac
	done
}

function take {
	mkdir -p $1
	cd $1
}

# ssh
function settitle() {
	printf "\033k$1\033\\"
}

function ssh() {
	if [ "$(ps -p $(ps -p $$ -o ppid=) -o comm=)" = "tmux" ]; then
		settitle "$(echo $* | rev | cut -d ' ' -f1 | rev | cut -d . -f 1)"
		command ssh "$@"
	else
		command ssh "$@"
	fi

	r=$?
	settitle "${SHELL##*/}"
	return $r
}

# Finder
alias o="open . &"
alias ff="open -a Firefox"

# Git
alias g="git"
alias gs="git status"
alias gb="git branch"
alias gba="git branch -a"
alias gco="git checkout"
alias ga="git add"
alias gc="git commit"
alias gd="git diff"
alias gdm="git diff master"
alias gp="git pull"
alias gf="git fetch"
alias gpu="git push"
alias gl="git log"
alias grm="git ls-files --deleted -z | xargs -0 git rm"
alias eg="$EDITOR .git/config"
alias egg="$EDITOR ~/.gitconfig"
# merge a subtree. Feed it with a remote name and the local branch (ex.: master)
alias gsm="git merge --squash -s subtree --no-commit"

# edit dirty files
alias edf="vim \$(git status -s -uno -z | sed 's/ M//g')"

stashgrep() {
	for i in `git stash list | awk -F ':' '{print $1}'`; do
		git stash show -p $i | grep -H --label="$i" "$1"
	done
}

# Emacs
alias em="open -a Emacs"
alias emm="open -a Emacs ."

# tags
function ct() {
	rm -f TAGS
	etags --append --output=TAGS $*
}

# Processes
alias tu='top -o cpu'
alias tm='top -o vsize'

# trace
function stc() {
	strace -f -s 4096 -o /tmp/trace.trc "$@"
}
function stp() {
	strace -f -s 4096 -o /tmp/trace.trc -p $1
}

# Rails
alias r="rake"
alias rmig="rake db:migrate"

# Ruby
alias irb="irb --readline -r irb/completion"
alias rii="ri -Tf ansi"

# open file. Can use xdg-open too. which one is better?
alias ']'="gnome-open"

# oracle
alias sqlplus='rlwrap /usr/bin/sqlplus /nolog'

# apt
alias aptu='sudo apt-get update && sudo apt-get dist-upgrade'
alias aptdu='sudo apt-get dist-upgrade'
alias apti='sudo apt-get install'
alias apts='apt-cache search'
alias aptsh='apt-cache show'

# pretty print of environment variables for a running process
function pp_env() {
	if [ $(id -u) -eq 0 ]; then
		sudo=""
	else
		sudo="sudo"
	fi
	$sudo bash -c "xargs --null --max-args=1 echo < /proc/$1/environ"
}

# find ssh host using substring
function fhost() {
	local part=$1

	[[ -f ~/.ssh/known_hosts ]] && hosts=$(awk '{print $1}' ~/.ssh/known_hosts | tr ',' '\n')
	#[[ -f ~/.ssh/config ]] && hosts_config=$(grep ^Host ~/.ssh/config | sed s/Host\ // | egrep -v '^\*$')
	#hosts=(${hosts[@]-} ${hosts_config[@]-})

	SAVE_IFS=$IFS
	IFS="\n"
	hosts_str="${hosts[*]}"
	IFS=$SAVE_IFS

	echo $hosts_str | grep $part
}

# k8s
alias kc='kubectl "--context=${KUBECTL_CONTEXT:-$(kubectl config current-context)}" ${KUBECTL_NAMESPACE/[[:alnum:]-]*/--namespace=${KUBECTL_NAMESPACE}}'
# alias kc="kubectl"
alias kcg="kc get"
alias kcgp="kc get pods --show-labels"
alias kcgs="kc get services"
alias kcgd="kc get deployments"
alias kcgc="kc get configmaps"
alias kcgss="kc get secrets"
alias kcgn="kc get namespaces"
alias kcgj="kc get jobs,cronjobs"
alias kcge="kc get events"
alias kcdp="kc describe pods"
alias kcd="kc describe"
alias kcdel="kc delete"
alias kcds="kc describe services"
alias kcdd="kc describe deployments"
alias kcdc="kc describe configmaps"
alias kcdss="kc describe secrets"
alias kce="kc exec -it"
alias kcl="kc logs"
alias kca="kc apply"
alias kcdelp="kc delete pod"
alias kcdeld="kc delete deploy"
alias kced="kc edit"
alias kcpf="kc port-forward"
alias mk=minikube
alias kinspect="kubectl run --rm -i -t vince-d --image=giantswarm/tiny-tools --restart=Never --command /bin/sh"
alias kcgpp="kubectl get pods -n kong-system-internal -o=jsonpath='{range .items[*]}{\"\n\"}{.metadata.name}{\":\t\"}{range .spec.containers[*]}{.name}{\"(\"}{.ports[*].name}{\" \"}{.ports[*].containerPort}{\")\"}{\", \"}{end}{end}' | sort"

alias kcccc="kubectl config current-context"
alias kccuc="kubectl config use-context"
alias kccgc="kubectl config get-contexts"

alias podinfo="kubectl get po -n kong-system-internal -o json | jq -r '.items[] | [(.metadata.name),([.spec.containers[].name] | join(\",\")),(.spec.nodeSelector[\"cloud.google.com/gke-nodepool\"])] | @tsv'"

function getcrb() {
    ns=$1
    sa=$2

    if [[ "$ns" == "" || "$sa" == "" ]]; then
        echo "paramètres requis: namespace, serviceaccount"
        return 1
    fi

    kubectl get clusterrolebindings -o json | jq -r $(cat <<-EOT
      .items[] |
      select(
        .subjects // [] | .[] |
        [.kind,.namespace,.name] == ["ServiceAccount\","${ns}","${sa}"]
      ) |
      .metadata.name
EOT
)
}

function kswitch() {
    if [[ "$@" == "" ]]; then
        echo -e "Missing namespace!"
        return 1
    fi

    ns=$1
    kubectl config set-context $(kubectl config current-context) --namespace="$ns"
}

function hswitch() {
    if [[ "$1" == "" ]]; then
        echo "** Paramètre obligatoire manqant"
        echo "** Liste des envs:"
        ls -1 ~/.creds/helm/envs/
        return 1
    fi

    pem_dir=~/.creds/helm/envs/$1

    cp ${pem_dir}/server/int.pem $(helm home)/ca.pem
    cp ${pem_dir}/user/client.pem $(helm home)/cert.pem
    cp ${pem_dir}/user/client-key.pem $(helm home)/key.pem
}

# ssl
function ssl_dump() {
	host=$1
	port=$2
	true | openssl s_client -showcerts -connect ${host}:${port} -servername ${host} | openssl x509 -noout -text
}
